import os, cv2, time
from PIL import Image
import numpy as np
import mmcv
from mmseg.apis import init_model, inference_model, show_result_pyplot
class Data:
    #relative paths to file directories. Should not be altered.
    root_dir = os.path.dirname(__file__)
    static = os.path.join(root_dir,"static")
    template = os.path.join(root_dir,"templates")
    image_dir = os.path.join(static,"images")
    model_dir = os.path.join(static,"models")
    save_dir = os.path.join(static,"save")

    def __init__(self):
        self.user = ""
        #default relative image and model paths
        self.img = "" #current image being analyzed
        self.grid_img = "" #grid image generated by application
        self.mask_img = "" #mask image generated from segmentation
        self.mask_img2 = "" #mask image selected for comparison
        self.config = "" #config file of model
        self.pth = "" #path file of model
        self.tile_img = "tile_overlay.png" #name of tile overlay to be shown in the app, fixed
        #delete the last tile overlay on initialize
        try:
            os.remove(os.path.join(self.static,self.tile_img))
        except:
            pass

        #Lists containing image and model paths. Does not include the empty option.
        self.image_idx, self.grid_idx, self.mask_idx, self.mask_idx2, self.model_idx = 0,0,0,0,0 #indices of current image and model
        self.image_list, self.grid_list, self.mask_list, self.model_list = [""],{"":[""]},{"":[""]},[""] #contains relative paths to directories. First entry is always empty.
        self.model = "" #contains currently loaded model
        self.point_text, self.output_text = "","" #text to be displayed in output boxes
        self.points = Points() #list of points
        self.point_classes = [] #list of point classes
        #image data
        self.img_w,self.img_l = 0,0 #dimensions of the image loaded

        #image display settings
        self.show_img = True
        self.show_grid = True
        self.show_mask = True
        self.w_scale, self.l_scale = 0, 0
        self.x_off, self.y_off = 0, 0
        self.zoom_level = 1

        #get currently loaded images and models
        self.get_images()
        self.get_models()
        self.get_paths()

    def get_images(self):
        #initialize lists of images
        self.image_list = [""]
        self.grid_list = {"":[""]}
        self.mask_list = {"":[""]}
        #gets the contents of the image directory
        images_dir = os.path.join(self.root_dir,self.image_dir)
        if not os.path.exists(images_dir):
            os.makedirs(images_dir,exist_ok=True)
        for folder in os.listdir(images_dir):
            folder_dir = os.path.join(images_dir,folder)
            if os.path.isdir(folder_dir):
                for file in os.listdir(folder_dir):
                    if os.path.isfile(os.path.join(folder_dir,file)) and os.path.splitext(file)[1] in [".png",".jpg",".jpeg"]:
                        #add image and all masks and grids saved for that image
                        image = os.path.relpath(folder_dir,self.image_dir).replace("\\","/")
                        self.image_list.append("images/" + os.path.join(folder,file).replace("\\","/"))
                        self.grid_list[folder]=[""]
                        self.mask_list[folder]=[""]
                        grids_dir = os.path.join(folder_dir,"grid")
                        masks_dir = os.path.join(folder_dir,"mask")
                        if not os.path.exists(grids_dir):
                            os.makedirs(grids_dir,exist_ok=True)
                        if not os.path.exists(masks_dir):
                            os.makedirs(masks_dir,exist_ok=True)
                        for grid in os.listdir(grids_dir):
                            if os.path.isfile(os.path.join(grids_dir,grid)) and os.path.splitext(grid)[1] == ".png":
                                self.grid_list[folder].append(folder + "/grid/" + grid)
                        for mask in os.listdir(masks_dir):
                            if os.path.isfile(os.path.join(masks_dir,mask)) and os.path.splitext(mask)[1] == ".png":
                                self.mask_list[folder].append(folder + "/mask/" + mask)
        self.image_list.sort()

    def get_models(self):
        #initialize lists of models
        self.model_list = [""]
        #gets the contents of the model directory
        models_dir = os.path.join(self.root_dir,self.model_dir)
        if not os.path.exists(models_dir):
            os.makedirs(models_dir,exist_ok=True)
        for folder in os.listdir(models_dir):
            folder_dir = os.path.join(models_dir,folder)
            if os.path.isdir(folder_dir):
                #add all models saved in the directory
                for file in os.listdir(folder_dir):
                    if ((os.path.splitext(file)[0]==folder) and (os.path.splitext(file)[1]==".pth") and os.path.isfile(os.path.splitext(os.path.join(folder_dir,file))[0]+".py")):
                        self.model_list.append(os.path.relpath(os.path.join(folder_dir,file),self.model_dir).replace("\\","/"))
        self.model_list.sort()


    #get paths for image files to display, assumes paths are correct
    def get_paths(self):
        #handle invalid indices
        if (self.image_idx >= len(self.image_list)):
            self.image_idx = 0
        image_key = os.path.split(os.path.split(self.image_list[self.image_idx])[0])[1]
        grids = self.grid_list.get(image_key,[""])
        masks = self.mask_list.get(image_key,[""])
        if (self.grid_idx >= len(grids)):
            self.grid_idx = 0
        if (self.mask_idx >= len(masks)):
            self.mask_idx = 0
        if (self.mask_idx2 >= len(masks)):
            self.mask_idx = 0
        if (self.model_idx >= len(self.model_list)):
            self.model_idx = 0
        #get image and model paths. Replace backslashes for compatibility with windows
        self.img = os.path.relpath(os.path.join(self.image_dir,self.image_list[self.image_idx]),self.template).replace("\\","/")
        self.grid_img = os.path.relpath(os.path.join(self.image_dir,image_key,"grid",grids[self.grid_idx]),self.template).replace("\\","/")
        self.mask_img = os.path.relpath(os.path.join(self.image_dir,image_key,"mask",masks[self.mask_idx]),self.template).replace("\\","/")
        self.mask_img2 = os.path.relpath(os.path.join(self.image_dir,image_key,"mask",masks[self.mask_idx2]),self.template).replace("\\","/")
        self.config = (os.path.splitext(os.path.relpath(os.path.join(self.model_dir,self.model_list[self.model_idx]),self.template))[0]+".py").replace("\\","/")
        self.pth = (os.path.splitext(os.path.relpath(os.path.join(self.model_dir,self.model_list[self.model_idx]),self.template))[0]+".pth").replace("\\","/")
            
    def update_image(self,image_name):
        self.get_images()
        try:
            self.image_idx = self.image_list.index(image_name)
        except ValueError: #load empty image if none found
            self.image_idx = 0
        self.img = self.image_list[self.image_idx]
        self.image_count = len(self.image_list)

    def update_grid(self,grid_name):
        self.get_images()
        try:
            self.grid_idx = self.grid_list[grid_name.split("/")[0]].index(grid_name)
        except ValueError: #load empty grid if none found
            self.grid_idx = 0
        self.grid_img = "images/" + self.grid_list[grid_name.split("/")[0]][self.grid_idx]
        self.grid_count = len(self.grid_list[grid_name.split("/")[0]])


    def update_mask(self,mask_name):
        self.get_images()
        try:
            self.mask_idx = self.mask_list[mask_name.split("/")[0]].index(mask_name)
        except ValueError: #load empty mask if none found
            self.mask_idx = 0
        self.mask_img = "images/" + self.mask_list[mask_name.split("/")[0]][self.mask_idx]
        self.mask_count = len(self.mask_list[mask_name.split("/")[0]])

    def update_mask2(self,mask_name):
        self.get_images()
        try:
            self.mask_idx2 = self.mask_list[mask_name.split("/")[0]].index(mask_name)
        except ValueError: #load empty mask if none found
            self.mask_idx2 = 0
        self.mask_img2 = "images/" + self.mask_list[mask_name.split("/")[0]][self.mask_idx2]
        self.mask_count = len(self.mask_list[mask_name.split("/")[0]])

    def update_model(self,model_name):
        self.get_models()
        try:
            self.model_idx = self.model_list.index(model_name)
        except ValueError: #load empty model if none found
            self.model_idx = 0
        self.config = "models/" + self.model_list[self.model_idx].split(".")[0] + ".py"
        self.pth = "models/" + self.model_list[self.model_idx].split(".")[0] + ".pth"
        self.model_count = len(self.model_list)

    def clear(self):
        #clear all loaded images, models, and text
        self.img, self.grid_img, self.mask_img, self.config, self.pth = "", "", "", "", ""
        self.model = "" #contains currently loaded model
        self.image_idx, self.grid_idx, self.mask_idx, self.mask_idx2, self.model_idx = 0,0,0,0,0
        self.get_images()
        self.get_models()
        self.get_paths()
        self.point_text, self.output_text = "",""
        self.points = Points()

class Points:
    def __init__(self,h_lines = [],v_lines = [],image = [],mask = [],classes = [],palette = []):
        self.h_lines = h_lines #positions of horizontal grid lines
        self.v_lines = v_lines #positions of vertical grid lines
        self.image = image #pixel representation of the image
        self.mask = mask #pixel representation of the segmentation mask
        self.classes = classes #classes of material in the model
        self.palette = palette #color palette used in the mask
        self.points = np.zeros((len(self.v_lines),len(self.h_lines),3),np.uint8) #stores the point colors
        self.point_class = [["" for i in range(len(self.h_lines))] for j in range(len(self.v_lines))] #stores the point classes
        for v in range(len(self.v_lines)):
            for h in range(len(self.h_lines)):
                self.points[v,h] = self.mask[self.v_lines[v],self.h_lines[h]][::-1]
                self.point_class[v][h] = self.classify_point(v,h)

    #Generates a tile for display. The tile is a temporary file located in the root of the static directory
    def make_tiles(self,dir_path=os.path.join(os.path.dirname(__file__),"static"),pt_rad=50):
        try:
            if pt_rad>0:
                #adjust pt_rad to never overlap with other tiles
                pt_rad = min(pt_rad,(self.v_lines[-1]-self.v_lines[0])/2,(self.h_lines[-1]-self.h_lines[0])/2)
                if not verify_path(dir_path,""):
                    logfile="Error: unable to save tilemap\n"
                    raise Exception
                mask_overlay = np.zeros(self.mask.shape, np.uint8)
                mask_overlay = cv2.cvtColor(mask_overlay, cv2.COLOR_BGR2BGRA)
                mask_overlay[:,:] = [0,0,0,0]
                for v in range(len(self.v_lines)):
                    for h in range(len(self.h_lines)):
                        r1,r2,r3,r4 =max(self.h_lines[h]-pt_rad,0),min(self.h_lines[h]+pt_rad,mask_overlay.shape[1]-1),max(self.v_lines[v]-pt_rad,0),min(self.v_lines[v]+pt_rad,mask_overlay.shape[0]-1)
                        mask_overlay[r3:r4,r1:r2,:3] = self.points[v,h]
                        mask_overlay[r3:r4,r1:r2,3] = 255
                mask_overlay = cv2.cvtColor(mask_overlay, cv2.COLOR_RGBA2BGRA)
                print(mask_overlay)
                cv2.imwrite(os.path.join(dir_path,"tile_overlay.png"),mask_overlay)
        except:
            logfile = "Unable to save tile overlay.\n"
        return

    def save_points(self,dir_path=os.path.dirname(__file__),save_path="save",log=False,pt_rad=0):
        logfile = ""
        try:
            save_path = os.path.join(save_path,f"{time.strftime('%m%y%d-%H%M%S',time.localtime(time.time()))}")
            if (log or pt_rad>0):
                if not verify_path(dir_path,save_path):
                    logfile="Error: unable to save results to file\n"
                    raise Exception
            if pt_rad > 0:
                pt_rad = min(pt_rad,(self.v_lines[-1]-self.v_lines[0])/2,(self.h_lines[-1]-self.h_lines[0])/2)
                pt_path = os.path.join(save_path,"sample_points")
                pt_mask_path = os.path.join(save_path,"mask_points")
                if not(verify_path(dir_path,pt_path) and verify_path(dir_path,pt_mask_path)):
                    logfile="Error: unable to save results to file\n"
                    raise Exception
                image_overlay = np.zeros(self.image.shape, np.uint8)
                image_overlay = cv2.cvtColor(image_overlay, cv2.COLOR_BGR2BGRA)
                image_overlay[:,:] = [127,127,127,255]
                mask_overlay = np.zeros(self.mask.shape, np.uint8)
                mask_overlay = cv2.cvtColor(mask_overlay, cv2.COLOR_BGR2BGRA)
                mask_overlay[:,:] = [127,127,127,255]
            class_count = []
            logfile += "Sample Coordinates:\n"
            for v in range(len(self.v_lines)):
                for h in range(len(self.h_lines)):
                    logfile += f"Point ({h}, {v}) ({self.h_lines[h]}, {self.v_lines[v]})\n"
                    logfile += f"{self.points[v,h]} => {self.point_class[v][h]}\n"
                    class_count.append(self.point_class[v][h])
                    if pt_rad > 0:
                        r1,r2,r3,r4 =max(self.h_lines[h]-pt_rad,0),min(self.h_lines[h]+pt_rad,image_overlay.shape[1]-1),max(self.v_lines[v]-pt_rad,0),min(self.v_lines[v]+pt_rad,image_overlay.shape[0]-1)
                        image_overlay[r3:r4,r1:r2,:3] = self.image[r3:r4,r1:r2]
                        mask_overlay[r3:r4,r1:r2,:3] = self.points[v,h]
                        mask_overlay[r3:r4,r1:r2,3] = 255
            if pt_rad > 0:
                mask_overlay = cv2.cvtColor(mask_overlay, cv2.COLOR_RGBA2BGRA)
                cv2.imwrite(os.path.join(dir_path,save_path,"image_overlay.png"),image_overlay)
                cv2.imwrite(os.path.join(dir_path,save_path,"mask_overlay.png"),mask_overlay)
                cv2.imwrite(os.path.join(dir_path,save_path,"image.png"),self.image)
                cv2.imwrite(os.path.join(dir_path,save_path,"mask.png"),self.mask)
            class_types = list(set(class_count))
            class_types.sort()
            for class_type in class_types:
                logfile += f"{class_type}: {round(class_count.count(class_type)*100/len(class_count),3)}%\n"
            if log:
                with open(f"{os.path.join(dir_path,save_path)}/coordinates.txt", "w+") as f:
                    f.write(logfile)
        except:
            logfile = "Unable to get points.\n"
        path = os.path.join(dir_path,save_path)
        return logfile, path

    def classify_point(self,y,x):
        try:
            for i in range(len(self.classes)):
                if tuple(self.points[y,x,:3]) == tuple(self.palette[i]):
                    return self.classes[i]
            return "UNKNOWN MATERIAL"
        except:
            return "NO MATCH"
    
    def update_point(self,y,x,new_class):
        msg = ""
        try:
            if (y >= len(self.classes) or y < 0 or x >= len(self.classes) or x < 0):
                msg += "Point is out of bounds."
                return msg
            for i in range(len(self.classes)):
                if new_class == self.classes[i]:
                    msg += (f"Changed point ({x},{y}) class from {self.point_class[y][x]} to {self.classes[i]}")
                    self.point_class[y][x] = self.classes[i]
                    self.points[y,x] = self.palette[i]
                    return msg
            msg += (f"Changed point ({x},{y}) class from {self.point_class[y][x]} to UNKNOWN MATERIAL")
            self.point_class[y][x] = "UNKNOWN MATERIAL"
            self.points[y,x] = self.palette[0]
            return msg
        except:
            msg += (f"Changed point ({x},{y}) class from {self.point_class[y][x]} to NO MATCH")
            self.point_class[y][x] = "NO MATCH"
            self.points[y,x] = self.palette[0]
            return msg

def verify_path(dir_path=os.path.dirname(__file__),file_path=""):
    #prevent any access to directories outside the project folder
    abs_path = os.path.abspath(os.path.join(dir_path, file_path))
    if not abs_path.lower().startswith(os.path.join(os.pardir,os.path.dirname(__file__)).lower()):
        return False
    try:
        os.makedirs(os.path.dirname(abs_path),exist_ok=True)
        return True
    except:
        return False

def verify_file(dir_path=os.path.dirname(__file__),file_path=""):
    if verify_path(dir_path,os.path.split(file_path)[0]):
        if os.path.isfile(os.path.abspath(os.path.join(dir_path, file_path))):
            return True
    return False

#All paths returned are relative paths to the program file at the root of the project directory.

def load_image(dir_path=os.path.join(os.path.dirname(__file__),"images"),image_path="",image_type="sample"):
    msg = ""
    image = ""
    try:
        if not verify_file(dir_path,image_path):
            raise Exception
        image = os.path.join(dir_path,image_path)
        msg += f"Loaded {image_type} image {image}\n"
    except:
        image = ""
        msg = f"Unable to load {image_type} image.\n"
    finally:
        return image, msg

def load_model_from_name(dir_path = "",model_path = ""):
    msg = ""
    try:
        config_path = model_path+".py"
        pth_path = model_path+".pth"
    except:
        config_path,pth_path = "",""
    finally:
        return load_model(dir_path,config_path,pth_path)

def load_model(dir_path=os.path.join(os.path.dirname(__file__),"models"),config_path = "",pth_path = ""):
    msg = ""
    cfg, pth, model = "", "", ""
    try:
        msg += f"Attempting to load segmenter config {os.path.join(dir_path,config_path)}\n"
        if not verify_file(dir_path,config_path):
            msg += "Unable to load segmenter config.\n"
            raise Exception
        cfg = os.path.join(dir_path,config_path)
        msg += f"Attempting to load segmenter path {os.path.join(dir_path,pth_path)}\n"
        if not verify_file(dir_path,pth_path):
            msg += "Unable to load segmenter path.\n"
            raise Exception
        pth = os.path.join(dir_path,pth_path)
        msg += "Loading segmentation model...\n"
        try:
            model = init_model(cfg, pth, device='cuda:0')
            msg += "Loaded segmentation model to gpu.\n"
        except AssertionError as e:
                model = init_model(cfg, pth, device='cpu')
                msg += "Loaded segmentation model to cpu.\n"
    except Exception as e:
        msg += f"Unable to load model: {e}\n"
    finally:
        return model

def segment_image(dir_path=os.path.join(os.path.dirname(__file__),"images"), mask_path="mask.mask.png",image = "", model = None, show=False,correct_mask = True):
    msg = ""
    mask_image = ""
    out_path = ""
    try:
        if not verify_file(dir_path,image):
            msg += "Please load an image first.\n"
            raise Exception
        elif model == None:
            msg += "Please load a model first.\n"
            raise Exception
        else:
            msg += f"Segmenting image {image}...\n"
            img_name = os.path.join(dir_path, image)
            mask_image = os.path.join(dir_path, mask_path)
            if correct_mask: #Correct masks that have their classes shifted left by 1 class
                model.dataset_meta["palette"]=model.dataset_meta["palette"][1:]+model.dataset_meta["palette"][:1]
                result = inference_model(model, img_name)
                show_result_pyplot(model=model, img=img_name, result=result, opacity=1.0, show=show,out_file=mask_image)
                model.dataset_meta["palette"]=model.dataset_meta["palette"][-1:]+model.dataset_meta["palette"][:-1] #revert palette to original
            else:
                result = inference_model(model, img_name)
                show_result_pyplot(model=model, img=img_name, result=result, opacity=1.0, show=show,out_file=mask_image)
            if not verify_file(dir_path,mask_image):
                msg += "Unable to load segmenter config.\n"
                raise Exception
    except Exception as e:
        mask_image = ""
        msg += f"Unable to generate segmented mask image: {e}\n"
    finally:
        msg += f"Segmented mask image generated to {mask_image}.\n"

    return mask_image,msg

def str2int(string,default = 0):
    try:
        return int(string)
    except:
        return default

def create_grid(dir_path=os.path.join(os.path.dirname(__file__),"images"), grid_path = "grid.grid.png",
                row_count = 5, col_count = 5, row_space = 320, col_space = 200,
                grid_w = 1920, grid_l = 1200, grid_x = 320, grid_y = 200):
    msg=""
    grid_image = ""
    os.makedirs(os.path.split(os.path.join(dir_path,grid_path))[0],exist_ok=True)
    if not grid_path.lower().endswith(".png"):
        grid_path = grid_path+".png"
    row_count = str2int(row_count,5)
    row_space = str2int(row_space,320)
    col_count = str2int(col_count,5)
    col_space = str2int(col_space,200)
    grid_w = str2int(string=grid_w, default=1920)
    grid_x = str2int(grid_x,320)
    grid_l = str2int(string=grid_l, default=1200)
    grid_y = str2int(string=grid_y, default=200)
    grid_height = row_count + (row_count * row_space) - row_space
    grid_width = col_count + (col_count * col_space) - col_space
    grid = np.zeros((grid_l,grid_w,4))
    for j in range(grid_l):
        for i in range(grid_w):
            if j >= grid_y and j < grid_y+grid_height and i >= grid_x and i < grid_x+grid_width:
                if (j-grid_y)%(col_space+1) == 0 and (i-grid_x)%(row_space+1) == 0:
                    grid[j,i]=(0,255,255,255)
                elif (j-grid_y)%(col_space+1) == 0:
                    grid[j,i]=((255,0,255,255) if j%2 == 0 else (128,0,128,255))
                elif (i-grid_x)%(row_space+1) == 0:
                    grid[j,i]=((255,255,0,255) if i%2 == 0 else (128,128,0,255))
                else:
                    grid[j,i]=(0,0,0,0)
    grid=Image.fromarray(grid.astype("uint8"),"RGBA")
    grid_image=os.path.join(dir_path, grid_path)
    grid.save(grid_image, "PNG")
    msg += f"Saved grid to {grid_path}\n"
    return grid_image,msg

def get_points(dir_path=os.path.join(os.path.dirname(__file__),"images"),image_path="",grid_path="",mask_path="",model="",save_path="save",timestamp=True):
    msg = ""
    if True:#try:
        #verify images
        if verify_file(dir_path,image_path):
            cv_image = cv2.imread(os.path.join(dir_path,image_path))
        else:
            msg += "No image found.\n"
            raise Exception
        if verify_file(dir_path,grid_path):
            cv_grid_image = cv2.imread(os.path.join(dir_path,grid_path))
        else:
            msg += "No grid image found.\n"
            raise Exception
        if verify_file(dir_path,mask_path):
            cv_mask_image = cv2.imread(os.path.join(dir_path,mask_path))
        else:
            msg += "No segmented mask image found.\n"
            raise Exception
        if model in ["",None]:
            msg += "No model loaded.\n"
            raise Exception

        image_l,image_w = cv_image.shape[0],cv_image.shape[1]
        cv_graygrid_image = cv2.cvtColor(cv_grid_image,cv2.COLOR_BGR2GRAY)
        cv2.imwrite(os.path.join(dir_path,"gridgray.png"),cv_graygrid_image)
        #Hough transform: obtain coordinates of grid intersections
        lines = cv2.HoughLines(cv_graygrid_image, 1, np.pi/180, 500)
        h_lines, v_lines = [],[]
        for line in lines:
            rho = line[0][0]
            theta = line[0][1]
            a = np.cos(theta)
            b = np.sin(theta)
            x0 = rho*np.cos(theta)
            y0 = rho*np.sin(theta)
            pt1 = (int(x0 + image_w*(-b)), int(y0 + image_l*(a)))
            pt2 = (int(x0 - image_w*(-b)), int(y0 - image_l*(a)))
            if theta == 0:
                h_lines.append(pt1[0])
            else:
                v_lines.append(pt2[1])
            cv2.line(cv_graygrid_image, pt1, pt2, (255,255,255), 3, cv2.LINE_AA)
        h_lines.sort()
        v_lines.sort()

        #verify that all points are within the image.
        if h_lines[-1] >= image_w and v_lines[-1] >= image_l:
            msg += "Grid image does not fit inside sample image.\n"
            #raise Exception

        #generate points object
        grid_points = Points(h_lines,v_lines,cv_image,cv_mask_image,model.dataset_meta["classes"],model.dataset_meta["palette"])
        msg += "Points obtained."

    #except Exception as e:
        #msg += "Unable to get points.\n"
        #grid_points = Points()
    return grid_points,msg